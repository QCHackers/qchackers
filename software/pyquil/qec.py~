from pyquil.quil import Program
#from pyquil.api import QPUConnection
from pyquil.api import QVMConnection
import pyquil.api as api
from pyquil.gates import *
import numpy as np
from pyquil.kraus import add_noise_to_program
from numpy import pi

# single step damping probability
damping_per_I = 0.02


#qpu = QPUConnection(device_name='19Q-Acorn')
qvm = api.QVMConnection()

qec = Program(
    H(1),
    T(1),
    H(1),
    H(0),
    H(1),
    H(2),
    CNOT(0,1),
    CNOT(2,1),
    H(0),
    H(1),
    H(2),
    
)
#print("Encoder into bit-flip code (qubits 0-2)")
#result = qpu.run_and_measure(qec, [0,1,2], 100)
#print(result)


qec = Program(
    I(0),
    I(1),
    I(4),
    I(5),
    CNOT(5,2),
    CNOT(0,2),
    CNOT(4,2),
    CNOT(1,2),
    
)
#print("Plaquette Z 0000")
#result = qpu.run_and_measure(qec, [2], 100)
#print(result)

def damping_channel(damp_prob=.1):
    """
    Generate the Kraus operators corresponding to an amplitude damping
    noise channel.

    :params float damp_prob: The one-step damping probability.
    :return: A list [k1, k2] of the Kraus operators that parametrize the map.
    :rtype: list
    """
    damping_op = np.sqrt(damp_prob) * np.array([[0, 1],
                                                [0, 0]])

    residual_kraus = np.diag([1, np.sqrt(1-damp_prob)])
    return [residual_kraus, damping_op]

def append_damping_to_gate(gate, damp_prob=.1):
    """
    Generate the Kraus operators corresponding to a given unitary
    single qubit gate followed by an amplitude damping noise channel.

    :params np.ndarray|list gate: The 2x2 unitary gate matrix.
    :params float damp_prob: The one-step damping probability.
    :return: A list [k1, k2] of the Kraus operators that parametrize the map.
    :rtype: list
    """
    return append_kraus_to_gate(damping_channel(damp_prob), gate)
num_I = 10


def append_kraus_to_gate(kraus_ops, g):
    """
    Follow a gate `g` by a Kraus map described by `kraus_ops`.

    :param list kraus_ops: The Kraus operators.
    :param numpy.ndarray g: The unitary gate.
    :return: A list of transformed Kraus operators.
    """
    return [kj.dot(g) for kj in kraus_ops]



def get_compiled_prog(theta):
    return Program([
        RZ(-pi/2, 0),
        RX(-pi/2, 0),
        RZ(-pi/2, 1),
        RX( pi/2, 1),
        CZ(1, 0),
        RZ(-pi/2, 1),
        RX(-pi/2, 1),
        RZ(theta, 1),
        RX( pi/2, 1),
        CZ(1, 0),
        RX( pi/2, 0),
        RZ( pi/2, 0),
        RZ(-pi/2, 1),
        RX( pi/2, 1),
        RZ(-pi/2, 1),
    ])


def H(qubit):    
   return 1
    
    
def get_compiled_prog_1():
    return Program([
        RX(pi/2, 0), 
        I(0),
        RZ(-pi/2, 0),

        RX(-pi/2, 0), 
        I(0),
        RZ(pi/2, 0),
    ])

p = Program()
p.inst(X(0))
# want increasing number of I-gates
p.define_noisy_gate("II", [0], append_damping_to_gate(np.eye(2), damping_per_I))
p.inst([I(0) for _ in range(num_I)])
#p.inst(H(0))
p.inst(MEASURE(0, [0]))
#print("Expected 1 %s" % qvm.run(p, [0]))

thetas = np.linspace(-pi, pi, num=20)
t1s = np.logspace(-6, -5, num=3)

#print(t1s[0])

prog = get_compiled_prog(pi/2)
noisy = add_noise_to_program(prog, T1=t1s[0]).inst([
            MEASURE(0, 0),
        ])
result = np.array(qvm.run(noisy, [0], 1))

print(result)

